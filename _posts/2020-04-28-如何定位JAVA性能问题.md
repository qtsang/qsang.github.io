---
layout: post
title: 如何定位Java性能问题
categories: JAVA
description: 如何定位Java性能问题。
keywords: Java,Jvm,性能分析


---

性能优化一向是后端服务优化的重点，但是线上性能故障问题不是经常出现，或者受限于业务产品，根本就没办法出现性能问题，为了提前储备知识，当出现问题的时候不会手忙脚乱，我们本篇文章根本实际或者模拟环境下常见的几个Java性能故障，来学习怎么去分析和定位。

> <font color=#008000>预备知识</font>

**lsof**命令

```shell
lsof -p 进程号         # 查看单个进程所有打开的文件详情
lsof -p 进程号 | wc -l   # 统计进程打开了多少文件
lsof -p 进程号 |grep 'sock' -c  #查看对应进程看的sock名称的数量
lsof -p 进程号 > openfiles.log  将执行结果内容输出到日志文件中查看(当文件太多的情况)
cat lsof.log | awk '{print $8}' | sort | uniq -c | sort -rn | head -n 10 #筛选出占用句柄前十的信息
```

**top命令**

`top`命令是我们最常用的Linux命令之一，它可以实时的显示当前正在执行的进程的CPU使用率，内存使用率等系统信息。`top -Hp pid` 可以查看线程的系统资源使用情况。

**vmstat命令**

vmstat是一个指定周期和采集次数的虚拟内存检测工具，可以统计内存，CPU，swap的使用情况，它还有一个重要的常用功能，用来观察进程的上下文切换。字段说明如下:

- r: 运行队列中进程数量（当数量大于CPU核数表示有阻塞的线程）
- b: 等待IO的进程数量
- swpd: 使用虚拟内存大小
- free: 空闲物理内存大小
- buff: 用作缓冲的内存大小(内存和硬盘的缓冲区)
- cache: 用作缓存的内存大小（CPU和内存之间的缓冲区）
- si: 每秒从交换区写到内存的大小，由磁盘调入内存
- so: 每秒写入交换区的内存大小，由内存调入磁盘
- bi: 每秒读取的块数
- bo: 每秒写入的块数
- in: 每秒中断数，包括时钟中断。
- cs: 每秒上下文切换数。
- us: 用户进程执行时间百分比(user time)
- sy: 内核系统进程执行时间百分比(system time)
- wa: IO等待时间百分比
- id: 空闲时间百分比

**pidstat命令**

pidstat 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，`top` 和 `vmstat` 两个命令都是监测进程的内存、CPU 以及 I/O 使用情况，而 pidstat 命令可以检测到线程级别的。`pidstat`命令线程切换字段说明如下：

- UID ：被监控任务的真实用户ID。
- TGID ：线程组ID。
- TID：线程ID。
- cswch/s：主动切换上下文次数，这里是因为资源阻塞而切换线程，比如锁等待等情况。
- nvcswch/s：被动切换上下文次数，这里指CPU调度切换了线程。

**jstack命令**

jstack是JDK工具命令，它是一种线程堆栈分析工具，最常用的功能就是使用 `jstack pid` 命令查看线程的堆栈信息，也经常用来排除死锁情况。

**jstat 命令**

它可以检测Java程序运行的实时情况，包括堆内存信息和垃圾回收信息，我们常常用来查看程序垃圾回收情况。常用的命令是`jstat -gc pid`。信息字段说明如下：

- S0C：年轻代中 To Survivor 的容量（单位 KB）；
- S1C：年轻代中 From Survivor 的容量（单位 KB）；
- S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；
- S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；
- EC：年轻代中 Eden 的容量（单位 KB）；
- EU：年轻代中 Eden 目前已使用空间（单位 KB）；
- OC：老年代的容量（单位 KB）；
- OU：老年代目前已使用空间（单位 KB）；
- MC：元空间的容量（单位 KB）；
- MU：元空间目前已使用空间（单位 KB）；
- YGC：从应用程序启动到采样时年轻代中 gc 次数；
- YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；
- FGC：从应用程序启动到采样时 老年代（Full Gc）gc 次数；
- FGCT：从应用程序启动到采样时 老年代代（Full Gc）gc 所用时间 (s)；
- GCT：从应用程序启动到采样时 gc 用的总时间 (s)。

**jmap命令**

jmap也是JDK工具命令，他可以查看堆内存的初始化信息以及堆内存的使用情况，还可以生成dump文件来进行详细分析。查看堆内存情况命令`jmap -heap pid`。

**mat内存工具**

MAT(Memory Analyzer Tool)工具是eclipse的一个插件(MAT也可以单独使用)，它分析大内存的dump文件时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用OQL对象查询，以及可以很方便的找出对象GC Roots的相关信息。

**idea中也有这么一个插件，就是JProfiler**。《性能诊断利器 JProfiler 快速入门和最佳实践》：**https://segmentfault.com/a/1190000017795841**

> <font color=#008000>应用场景</font>

**一、打开文件句柄数过多(too many open files) **

一般报too many open files是因为文件打开数超过了系统设置的最大的打开文件数，出现这类问题，首先可以调整操作系统的最大文件数，如果还不能解决问题，则需要看一下代码是否存在打开没有关闭的情况。

1. 从系统级别处理

   ```
   ulimit -u 查看open files设置 默认好像是1024 linux
   ulimit -a 查看所有设置
   ulimit -u 65535(新的open files 值)修改设置
   ulimit -n 65536 设置用户可以同时打开的最大文件数（max open files） 默认是2048
   如果本参数设置过小，对于并发访问量大的网站，可能会出现too many open files的错误 
   使用lsof -p pid [httpd进程的 pid、java的pid]来查看系统中apache进程和java运行时进程当前打开的文件资源，发现两者之和已
   经接近1024，大于了默认的设置
   
   1、修改配置：（我看机器上好像都有）
   修改/etc/security/limits.conf，在文件末加上
   * soft nofile 65536
   * hard nofile 65536
   
   2、检查 /etc/bashrc文件
   看是否有  ulimit -n 2048 ，有的话注释掉
   3、修改 /etc/profile 文件
   添加
   ulimit -u 65535
   ulimit -SHn 65535
   4、 /etc/pam.d/su /etc/pam.d/sshd /etc/pam.d/login 文件中添加
         session    required     pam_limits.so
   这个也看到过 ，加不加不知道有没有效果
   ```

   

2. 通过lsof分析

```
lsof -p 进程号         # 查看单个进程所有打开的文件详情
lsof -p 进程号 | wc -l   # 统计进程打开了多少文件
lsof -p 进程号 |grep 'sock' -c  #查看对应进程看的sock名称的数量
lsof -p 进程号 > lsof.log  将执行结果内容输出到日志文件中查看(当文件太多的情况),可以将日志下载到本地
cat lsof.log | awk '{print $8}' | sort | uniq -c | sort -rn | head -n 10 #筛选出占用句柄前十的信息
netstat -tnpoa|grep 进程号
strace -p 进程


```

查看lsof.log发现是使用spring restemplate造成的，默认情况下使用SimpleClientHttpRequestFactory，这个是不带连接池的，每次发起一请求，都会创建一个连接，高并发时就会出现too many open files，改成带连接池的HttpComponentsClientHttpRequestFactory就解决了。





